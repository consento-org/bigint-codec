import { Buffer } from 'buffer'

/**
 * Returns all bytes of a bigint number
 *
 * @param {bigint} bigint number to be turned into bytes
 * @returns {Iterator<number>}
 */
export function * encodeBytes (bigint) {
  if (bigint < 0n) {
    bigint = (bigint * -1n) << 1n | 1n
  } else {
    bigint = bigint << 1n
  }
  while (bigint >= 256n) {
    const rem = bigint % 256n
    bigint = bigint / 256n
    yield Number(rem)
  }
  yield Number(bigint)
}

/**
 * Turns bytes generated by encodeBytes into a bigint
 *
 * @param {Iterable<number>} bytes bytes to be turned into bigint
 * @returns {bigint}
 */
export function decodeBytes (bytes) {
  let result = 0n
  let base = 1n
  for (const byte of bytes) {
    result += BigInt(byte) * base
    base *= 256n
  }
  if ((result & 1n) === 1n) {
    return (result >> 1n) * -1n
  }
  return result >> 1n
}

/**
 * Iterates over a bytes from a given offset until a max size
 *
 * @param {number[]|Uint8Array} bytes
 * @param {number} [offset]
 * @param {number} [size]
 * @returns {Iterator<number>}
 */
export function * bytesIter (bytes, offset = 0, size) {
  const max = typeof size === 'number' ? offset + size : bytes.length
  while (offset < max) {
    yield bytes[offset++]
  }
}

export const codec = Object.freeze({
  name: 'bigint',
  bytesIter,
  encodeBytes,
  decodeBytes,
  /**
   * Encodes a bigint number directly into a Buffer instance.
   *
   * @param {bigint} bigint
   * @param {number[]|Uint8Array} [byob]
   * @param {number} [offset]
   * @returns {Buffer}
   */
  encode (bigint, byob = [], offset = 0) {
    for (const byte of encodeBytes(bigint)) {
      byob[offset++] = byte
    }
    return Buffer.isBuffer(byob) ? byob : Buffer.from(byob)
  },
  /**
   * Decodes a bigint number from a Uint8Array (or number[])
   *
   * @param {number[]|Uint8Array} bytes
   * @param {number} [offset]
   * @param {number} [size]
   */
  decode (bytes, offset, size) {
    return decodeBytes(bytesIter(bytes, offset, size))
  }
})

export default codec
